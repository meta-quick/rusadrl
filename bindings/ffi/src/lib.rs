// Copyright 2024 meduo <gao.brian@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/*! C bindings for the RUSADRL library.

This crate defines the C-compatible API that C/C++ programs can use for
interfacing with the odrl Rust library. A header file for this library
(`odrl.h`) will be automatically generated by [`cbindgen`][1], during
compilation, together with dynamic-linking and static-linking versions of
the library.

# How to build and install

*/
use std::ffi::{CString, CStr};
use std::os::raw::c_char;
use std::ptr::null_mut;
use std::str::FromStr;
use iref::IriBuf;

fn to_iri(s: &str) -> Option<IriBuf> {
    IriBuf::from_str(s).ok()
}

mod ffi {
    use std::borrow::BorrowMut;
    use std::ptr::null_mut;
    use tokio::runtime::Runtime;
    use rusadrl::{CONFIG, odrl_loader::OdrlLoader};
    use rusadrl::model::policy::{OdrlRequest, PolicyEngine};
    use rusadrl::model::stateworld::{StateWorld, GLOBAL_WORLD_CACHE};

    pub struct Engine;

    impl Engine {
        pub fn set_verbose(verbose: bool) {
            let mut config = CONFIG.lock().unwrap();
            let config = config.borrow_mut();
            config.set_verbose(verbose);
        }

        pub fn create_odrl_world(odrl: String) ->  *mut i64 {
            let rt = Runtime::new().unwrap();
            let policy = rt.block_on(async {
                let doc = OdrlLoader::load_json("http://www.w3.org/ns/odrl/2".to_string(),odrl);

                let doc = doc.await;
                if doc.is_err() {
                    return Err(doc.unwrap_err());
                }
                let expanded = doc.unwrap();
                let policy = OdrlLoader::parse(expanded).await;
                if policy.is_err() {
                    return Err(policy.unwrap_err());
                }
                let policy = OdrlLoader::compile(&mut policy.unwrap()).await;
                policy
            });

            if policy.is_err() {
                return null_mut();
            }

            //return policy into raw pointer
            let policy = policy.unwrap();
            Box::into_raw(Box::new(policy)) as  *mut i64
        }


        pub fn policy_evaluate(handle: *mut i64, req: OdrlRequest) -> i32 {
            //convert odrl_world into *mut i64
            if handle.is_null() {
                return -1;
            }
            let odrl = unsafe {
                &mut *(handle as *mut rusadrl::model::policy::PolicyUnion)
            };

            //find world
            let mut iri = PolicyEngine::find_world_key(odrl);
            if iri.is_none() {
                return -1;
            }
            let mut cache = GLOBAL_WORLD_CACHE.lock().unwrap();
            let world = cache.find_world(iri.unwrap().as_str());
            if world.is_none() {
                return -1;
            }
            let mut world = world.unwrap();

            let result = PolicyEngine::eval(world,odrl,&req);

            if result.is_err() {
                return -1;
            }
            return result.unwrap() as i32;
        }

        pub fn delete_odrl_world(ptr: *mut i64) {
            if ptr.is_null() {
                return;
            }

            unsafe {
               let _result =  Box::from_raw(ptr);
            }
        }
    }
}

#[no_mangle]
pub extern "C" fn enable_verbose(verbose: i32) -> i32 {
    ffi::Engine::set_verbose(verbose!=0);
    0
}

#[no_mangle]
pub extern "C" fn delete_odrl_world(ptr: *mut i64) -> i32 {
    ffi::Engine::delete_odrl_world(ptr);
    0
}


#[no_mangle]
pub extern "C" fn create_odrl_world(odrl: *const c_char) ->  *mut i64 {
    if odrl.is_null() {
        return null_mut();
    }

    let odrl = unsafe { CStr::from_ptr(odrl).to_string_lossy().into_owned() };
    let result = ffi::Engine::create_odrl_world(odrl);
    result
}

#[cfg(test)]
mod tests {
    use rusadrl::model::policy::OdrlRequest;
    use super::*;
    #[test]
    fn it_works() {
        let json = r#"{
	"@context": [
		"https://www.w3.org/ns/odrl.jsonld",
		{
			"title": "https://datasafe.io/ds/1.1/title",
			"creator": "https://datasafe.io/ds/1.1/creator",
			"dateCreated": "https://datasafe.io/ds/1.1/dateCreated"
		}
	],
	"type": "Agreement",
	"uid": "http://abc.tds/policy/demo/1",
	"assigner": {
		"uid": "https://aa/bb/gaosg",
		"type": "Party",
		"assignerOf": "http://aaa/a",
		"refinement": {
            "dataType": "integer",
            "unit": "m",
            "leftOperand": "dateTime",
            "operator": "lt",
            "rightOperand": "abc"
		}
	},
	"assignee": {
		"uid": "https://aa/gaosg",
		"type": "PartyCollection",
		"source": "https://aa.com/aaa",
		"refinement": {
            "dataType": "integer",
            "unit": "m",
            "leftOperand": "dateTime",
            "operator": "lt",
            "rightOperand": "abc"
        }
	},
    "target": "http://ab/a",
	"title": "Policy 1",
	"conflict": "Perm",
	"inheritFrom": ["http://a.com/abc", "http://a.com/abc"],
	"profile": "http://a.com/abc",
	"permission": [{
			"action": "use",
			"assignee": "http://abc/liumazi",
			"constraint": {
				"dataType": "integer",
				"unit": "m",
				"leftOperand": "dateTime",
				"operator": "lt",
				"rightOperand": "abc"
			}
		},
		{
			"action": "use",
			"constraint": {
				"type": "LogicalConstraint",
				"uid": "http://example.com/constraint/1",
				"operator": "and",
				"constraint": [{
						"leftOperand": "dateTime",
						"operator": "gt",
						"rightOperandReference": "http://a/a"
					},
					{
						"leftOperand": "dateTime",
						"operator": "lt",
						"rightOperand": "2025-12-31"
					}
				]
			}
		}
	]
}"#;

        enable_verbose(1);

        //covert json to *const c_char
        let json = CString::new(json).unwrap();
        let handle = create_odrl_world(json.as_c_str().as_ptr());

        //eval policy
        let mut req = OdrlRequest::default();
        req.set_action(to_iri("use"));
        req.set_assignee(to_iri("http://example.com/liumazi"));
        req.set_assigner(to_iri("http://example.com/liumazi"));
        req.set_target(to_iri("http://example.com/liumazi"));
        let result = ffi::Engine::policy_evaluate(handle,req);
        println!("result: {:?}", result);
    }
}

