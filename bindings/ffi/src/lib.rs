// Copyright 2024 meduo <gao.brian@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/*! C bindings for the RUSADRL library.

This crate defines the C-compatible API that C/C++ programs can use for
interfacing with the odrl Rust library. A header file for this library
(`odrl.h`) will be automatically generated by [`cbindgen`][1], during
compilation, together with dynamic-linking and static-linking versions of
the library.

# How to build and install

*/
#![allow(dead_code)]

use std::ffi::{CStr};
use std::os::raw::c_char;
use std::ptr::null_mut;
use std::str::FromStr;
use iref::IriBuf;
use rusadrl::model::policy::OdrlRequest;

pub fn to_iri(s: &str) -> Option<IriBuf> {
    IriBuf::from_str(s).ok()
}

pub mod ffi {
    use std::borrow::BorrowMut;
    use std::ffi::{c_char, CStr, CString};
    use std::ptr::null_mut;
    use std::str::FromStr;
    use iref::IriBuf;
    use tokio::runtime::Runtime;
    use rusadrl::{CONFIG, odrl_loader::OdrlLoader, handle_to_policy};
    use rusadrl::model::policy::{OdrlRequest, PolicyEngine};
    use rusadrl::model::stateworld::{GLOBAL_WORLD_CACHE};

    pub struct Engine;

    impl Engine {
        pub fn set_verbose(verbose: bool) {
            let mut config = CONFIG.lock().unwrap();
            let config = config.borrow_mut();
            config.set_verbose(verbose);
        }

        pub fn create_odrl_world(odrl: String) ->  *mut i64 {
            let rt = Runtime::new().unwrap();
            let policy = rt.block_on(async {
                let doc = OdrlLoader::load_json("http://www.w3.org/ns/odrl/2".to_string(),odrl);

                let doc = doc.await;
                if doc.is_err() {
                    return Err(doc.unwrap_err());
                }
                let expanded = doc.unwrap();
                let policy = OdrlLoader::parse(expanded).await;
                if policy.is_err() {
                    return Err(policy.unwrap_err());
                }
                let policy = OdrlLoader::compile(&mut policy.unwrap()).await;
                policy
            });

            if policy.is_err() {
                return null_mut();
            }

            //return policy into raw pointer
            let policy = policy.unwrap();
            Box::into_raw(Box::new(policy)) as  *mut i64
        }


        pub fn policy_evaluate(handle: *mut i64, req: OdrlRequest) -> i32 {
            //convert odrl_world into *mut i64
            if handle.is_null() {
                return -1;
            }
            let odrl = unsafe {
                &mut *(handle as *mut rusadrl::model::policy::PolicyUnion)
            };

            //find world
            let iri = PolicyEngine::find_world_key(odrl);
            if iri.is_none() {
                return -1;
            }
            let cache = GLOBAL_WORLD_CACHE.clone();
            let world = cache.find_world(iri.unwrap().as_str());
            if world.is_none() {
                return -1;
            }
            let mut world = world.unwrap();

            let result = PolicyEngine::eval(world.value_mut(),odrl,&req);

            if result.is_err() {
                return -1;
            }
            return result.unwrap() as i32;
        }

        pub fn delete_odrl_world(ptr: *mut i64) {
            if ptr.is_null() {
                return;
            }

            unsafe {
               let _result =  Box::from_raw(ptr);
            }
        }

        pub fn fetch_odrl_world(handle: *mut i64,key: *const c_char) ->  *const c_char {
            //convert odrl_world into *mut i64
            if handle.is_null() || key.is_null() {
                return null_mut();
            }

            let key = unsafe { CStr::from_ptr(key).to_string_lossy().into_owned() };
            let key = IriBuf::from_str(&key);
            if key.is_err() {
                return null_mut();
            }
            let key = key.unwrap();

            let policy = handle_to_policy(handle);
            if policy.is_none() {
                return null_mut();
            }

            let policy = policy.unwrap();
            let world_key = PolicyEngine::find_world_key(policy);
            if world_key.is_none() {
                return null_mut();
            }

            let world_key = world_key.unwrap();
            let cache = GLOBAL_WORLD_CACHE.clone();
            let state = cache.find_world(world_key.as_str());
            if state.is_none() {
                return null_mut();
            }
            let state = state.unwrap();

            let state = state.value().get_state(&key);
            if state.is_none() {
                return null_mut();
            }

            let state = state.unwrap();
            let result = CString::new(state).unwrap();
            result.into_raw()
        }

        pub fn update_odrl_world(handle: *mut i64,key: *const c_char,val: *const c_char) ->  i32 {
            //convert odrl_world into *mut i64
            if handle.is_null() || key.is_null() || val.is_null() {
                return -1;
            }

            let key = unsafe { CStr::from_ptr(key).to_string_lossy().into_owned() };
            let key = IriBuf::from_str(&key);
            if key.is_err() {
                return -1;
            }
            let key = key.unwrap();

            let policy = handle_to_policy(handle);
            if policy.is_none() {
                return -1;
            }
            let policy = policy.unwrap();
            let world_key = PolicyEngine::find_world_key(policy);
            if world_key.is_none() {
                return -1;
            }

            let world_key = world_key.unwrap();
            let cache = GLOBAL_WORLD_CACHE.clone();
            let state = cache.find_world(world_key.as_str());
            if state.is_none() {
                return -1;
            }
            let mut state = state.unwrap();

            let val = unsafe { CStr::from_ptr(val).to_string_lossy().into_owned() };
            state.value_mut().update_state(key.as_str(),val.as_str());
            return 0;
        }

        pub fn add_odrl_world(handle: *mut i64,key: *const c_char,val: *const c_char) ->  i32 {
            Engine::update_odrl_world(handle, key, val)
        }

        pub fn remove_odrl_world(handle: *mut i64,key: *const c_char) ->  i32 {
            //convert odrl_world into *mut i64
            if handle.is_null() || key.is_null() {
                return -1;
            }

            let key = unsafe { CStr::from_ptr(key).to_string_lossy().into_owned() };
            let key = IriBuf::from_str(&key);
            if key.is_err() {
                return -1;
            }
            let key = key.unwrap();

            let policy = handle_to_policy(handle);
            if policy.is_none() {
                return -1;
            }

            let policy = policy.unwrap();
            let world_key = PolicyEngine::find_world_key(policy);
            if world_key.is_none() {
                return -1;
            }

            let world_key = world_key.unwrap();
            let cache = GLOBAL_WORLD_CACHE.clone();
            let state = cache.find_world(world_key.as_str());
            if state.is_none() {
                return -1;
            }
            let mut state = state.unwrap();

            state.value_mut().remove_state(key.as_str());
            return 0;
        }
    }
}

#[no_mangle]
pub extern "C" fn enable_verbose(verbose: i32) -> i32 {
    ffi::Engine::set_verbose(verbose!=0);
    0
}

#[no_mangle]
pub extern "C" fn delete_odrl_world(ptr: *mut i64) -> i32 {
    ffi::Engine::delete_odrl_world(ptr);
    0
}


#[no_mangle]
pub extern "C" fn create_odrl_world(odrl: *const c_char) ->  *mut i64 {
    if odrl.is_null() {
        return null_mut();
    }

    let odrl = unsafe { CStr::from_ptr(odrl).to_string_lossy().into_owned() };
    let result = ffi::Engine::create_odrl_world(odrl);
    result
}

#[no_mangle]
pub extern "C" fn eval_odrl_world(handle: *mut i64,action: *const c_char,target: *const c_char,assigner: *const c_char,assignee: *const c_char) ->  i32 {
    ffi::Engine::set_verbose(true);

    //eval policy
    if handle.is_null() {
        return -1;
    }

    let mut req = OdrlRequest::default();
    if action.is_null() {
        return -1;
    }
    let action = unsafe { CStr::from_ptr(action).to_string_lossy().into_owned() };
    req.set_action(to_iri(action.as_str()));

    if target.is_null() {
        return -1;
    }
    let target = unsafe { CStr::from_ptr(target).to_string_lossy().into_owned() };
    req.set_target(to_iri(target.as_str()));

    if !assigner.is_null() {
        let assigner = unsafe { CStr::from_ptr(assigner).to_string_lossy().into_owned() };
        req.set_assigner(to_iri(assigner.as_str()));
    }

    if !assignee.is_null() {
        let assignee = unsafe { CStr::from_ptr(assignee).to_string_lossy().into_owned() };
        req.set_assignee(to_iri(assignee.as_str()));
    }

    let result = ffi::Engine::policy_evaluate(handle,req);
    result
}

#[no_mangle]
pub extern "C" fn update_odrl_world(handle: *mut i64,key: *const c_char,value: *const c_char) ->  i32 {
    ffi::Engine::update_odrl_world(handle, key, value)
}

#[no_mangle]
pub extern "C" fn fetch_odrl_world(handle: *mut i64,key: *const c_char) ->  *const c_char {
    ffi::Engine::fetch_odrl_world(handle, key)
}

#[no_mangle]
pub extern "C" fn remove_odrl_world(handle: *mut i64,key: *const c_char) ->  i32 {
    ffi::Engine::remove_odrl_world(handle, key)
}

#[cfg(test)]
mod tests {
    use std::ffi::CString;
    use rusadrl::model::policy::OdrlRequest;
    use super::*;
    #[test]
    fn it_works() {
        let json = r#"{
	"@context": [
		"https://www.w3.org/ns/odrl.jsonld",
		{
			"title": "https://datasafe.io/ds/1.1/title",
			"creator": "https://datasafe.io/ds/1.1/creator",
			"dateCreated": "https://datasafe.io/ds/1.1/dateCreated"
		}
	],
	"type": "Agreement",
	"uid": "https://datasate.ids/aggreement/00001",
	"assigner": {
		"uid": "https://datasate.ids/users/gaosg",
		"type": "Party",
		"assignerOf": "https://datasate.ids/dataset/00001",
		"refinement": {
            "dataType": "dateTime",
            "unit": "m",
            "leftOperand": "dateTime",
            "operator": "lt",
            "rightOperand": "2025-12-31"
		}
	},
	"assignee": {
		"uid": "https://datasate.ids/usercollection/liumazi",
		"type": "PartyCollection",
		"source": "https://datasate.ids/usercollection/liumazi",
		"refinement": {
            "dataType": "dateTime",
            "unit": "m",
            "leftOperand": "dateTime",
            "operator": "lt",
            "rightOperand": "2025-12-31"
        }
	},
    "target": "https://datasate.ids/llm/dataset/0001",
	"title": "Policy 1",
	"conflict": "Perm",
	"inheritFrom": [],
	"profile": "https://datasate.ids/profiles/0001",
	"permission": [{
			"action": "use",
			"assignee": "https://datasate.ids/usercollection/liumazi",
			"constraint": {
				"dataType": "dateTime",
				"unit": "m",
				"leftOperand": "dateTime",
				"operator": "lt",
				"rightOperand": "2024-12-31"
			}
		},
		{
			"action": "use",
			"constraint": {
				"type": "LogicalConstraint",
				"uid": "https://datasate.ids/users/gaosg",
				"operator": "and",
				"constraint": [{
				        "unit": "cm",
				        "dataType": "dateTime",
						"leftOperand": "dateTime",
						"operator": "gt",
						"rightOperand": "2024-12-31"
					},
					{
					    "dataType": "dateTime",
						"leftOperand": "dateTime",
						"operator": "lt",
						"rightOperand": "2024-12-31"
					}
				]
			}
		}
	]
}"#;

        enable_verbose(1);

        //covert json to *const c_char
        let json = CString::new(json).unwrap();
        let handle = create_odrl_world(json.as_c_str().as_ptr());

        //eval policy
        let mut req = OdrlRequest::default();
        req.set_action(to_iri("http://www.w3.org/ns/odrl/2/use"));
        req.set_assignee(to_iri("https://datasate.ids/usercollection/liumazi"));
        req.set_assigner(to_iri("https://datasate.ids/users/gaosg"));
        req.set_target(to_iri("https://datasate.ids/llm/dataset/0001"));
        let result = ffi::Engine::policy_evaluate(handle,req);
        println!("result: {:?}", result);
    }
}

